# 生命周期:
* 一个组件从创建到销毁的一个过程
* 生命周期函数--->生命周期钩子函数
* 创建过程    挂载过程    更新过程   销毁过程
---
[官方文档(生命周期)](https://cn.vuejs.org/v2/api/#beforeCreate)
---
#### 1. beforeCreate:创建前
1. 当new Vue执行的时候，beforeCreate会做一个初始化的操作，
2. 在当前生命周期中我们访问不到data中的属性和methods身上的方法,
3. 当前生命周期中我们可以执行一个loading当页面加载完毕的时候将loading移除即可

#### 2. created:创建后(常用)
1. 当前生命周期在执行的时候会将data中所有的属性
2. 以及methods里面所有的方法都挂载在Vue的实例身上
3. 当前生命周期会将data里面所有的属性都进行数据的劫持给每一个属性都添加一个getter、setter方法
4. 当前生命周期中我们可以进行前后端数据的交互(ajax的请求)
5. created是一个创建的过程,页面并没有被渲染,当在这里进行数据的请求以后,在挂载过程中直接拿到当前的数据在页面中渲染
6. 如果在其他生命周期中获取数据 , 会导致created和那个生命周期各自做一次渲染,浪费性能,所以要在created中做数据的请求

#### 3.  beforeMount：挂载前
* 模板与数据进行结合但是并没有渲染到页面上，因此我们可以在当前生命周期中做数据最后的一次更改

#### 4. mounted:挂载后(常用)
1. 模板与数据进行结合完毕，并且已经挂载到了页面上。
2. 我们可以在当前生命周期中获取到真实的DOM结构
3. 在Vue中如果需要操作DOM元素了必须通过this.$refs.属性 以及给当前元素添加一个ref属性 然后进行操作   
    - 关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。
    - 可以做的事情
        1. 操作真实的DOM
        2. 方法的实例化 new **
        3. `注意：ref的值必须是唯一的`

#### 5. beforeUpdate:更新前(会被多次调用)
1. 当前生命周期在数据更新的时候就会执行
2. 更新的数据与模板还未结合，因此我们可以在当前生命周期中做数据最后的修改,同时也可以监听数据的变化，
        
#### 6. updated:更新后(会被多次调用)
1. 数据与模板进行相结合并且已经挂载到了页面上，因此我们可以在当前生命周期中获取数据更新后最新的DOM结构
2. 需要做条件处理
3. 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用`计算属性`或` watcher `取而代之。
4. `注意` 
    1. updated 不会承诺所有的子组件也都一起被重绘。
    2. 如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 updated：
    ```JavaScript
    updated: function () {
    this.$nextTick(function () {
        // Code that will run only after the
        // entire view has been re-rendered
    })
    }
    ```

#### 7. beforeDestroy：销毁前 (常用)
1. 当前生命周期需要做一些移除操作,例如`事件的解绑` `监听的移除` `定时器的移除`等等操作

#### 8. destroyed：销毁后
1. 当前生命周期在执行的时候会将vm与页面之间的关系件断开(数据与视图之间的关系进行断开)

