# 用过那些优化方法

1. import()路由懒加载
2. keep-alive
   1. 被包裹在keep-alive中的组件的状态将会被保留，
   2. 例如我们将某个列表类组件内容滑动到第100条位置，那么我们在切换到一个组件后再次切换回到该组件，该组件的位置状态依旧会保持在第100条列表处
3. 浏览器缓存
4. 频繁切换的使用v-show，不频繁切换的使用v-if,安全性
5. 尽量少用float，可以用flex
6. 按需加载，可以用require或者import()按需加载需要的组件
7. 服务端渲染
8. 一般切完图后我会把图片压缩一次，这样可以减小图片的体积，压缩工具我用得是这个 tinypng.com/，免费的，而且压缩完分辨率也跟原来差不多，视觉上不会有太大的影响。一些小图标，做成雪碧图能减少图片请求数据，建议只把那些固定的，后期不会修改的图标做成雪碧图，如果是那些要经常改动的就不建议这么做发，因为一旦要修改就连其它地方也要修改了，如果项目比较复杂的话可能连自己都忘了要改哪里了。


9.  React中 
   1. shouldComponentUpdate,
      - React中的`性能优化`依靠当前生命周期，因为当前生命周期可以决定render函数是否执行
      - 当前生命周期中会有2个参数
      - 一个是新的props
      - 一个是新的State我们可以用新旧的state/props进行对比来,决定返回true/false
    1. componentDidUpdate
       - 当前生命周期是数据和模板更新完毕，我们可以在当前生命周期中获取到数据更新后最新的DOM结构
      - 但是要注意的是一定要做边界条件判断
      ```js
          componentDidUpdate() {
              // 做边界条件判断
              if(!this.swiper){
                  this.swiper = new Swiper('')
              }

          }
      ```
# 常见的兼容问题

1. png24位的图片在iE6浏览器上出现背景
   1. 解决方案是做成PNG8.

2. 浏览器默认的margin和padding不同。    
   1. 解决方案是加一个全局的*{margin:0;padding:0;}来统一。

3. 浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） 
#box{ float:left; width:10px; margin:0 0 0 100px;}

